# frozen_string_literal: true

# The Runkit main class
module Runkit
    # Result value when reading a port whose value has already been read
    #
    # Unlike within RTT, 'NO_DATA' is represented by a false value
    #
    # @see NEW_DATA
    OLD_DATA = 0

    # Result value when reading a port which has a new (never read) value
    #
    # Unlike within RTT, 'NO_DATA' is represented by a false value
    #
    # @see OLD_DATA
    NEW_DATA = 1

    class AlreadyInitialized < RuntimeError; end
    class InternalError < RuntimeError; end
    class AmbiguousName < RuntimeError; end
    class PropertyChangeRejected < RuntimeError; end

    class NotFound < RuntimeError; end
    class TypekitNotFound < NotFound; end
    TypekitTypeNotFound    = OroGen::NotTypekitType
    TypekitTypeNotExported = OroGen::NotExportedType

    # Exception raised when an operation requires the CORBA layer to be
    # initialized by Runkit.initialize has not yet been called
    class NotInitialized < RuntimeError; end

    # Emitted when an interface object is requested, that does not exist
    class InterfaceObjectNotFound < Runkit::NotFound
        attr_reader :task
        attr_reader :name

        def initialize(task, name)
            @task = task
            @name = name
            super()
        end
    end

    # Exception raised when the user tries an operation that requires the
    # component to be generated by oroGen, while the component is not
    class NotOrogenComponent < RuntimeError; end

    # Base class for all exceptions related to communication with remote
    # processes
    class ComError < RuntimeError; end

    class << self
        # If true, the runkit logfile that is being generated by this Ruby
        # process is kept. By default, it gets removed when the ruby process
        # terminates
        attr_predicate :keep_runkit_logfile?, true

        # The name of the runkit logfile for this Ruby process
        attr_reader :runkit_logfile

        # @return [RubyTasks::TaskContext] the ruby task context that is used to
        #   provide a RTT interface to this Ruby process. Among other things, it
        #   manages the data readers and writers
        attr_reader :ruby_task

        # Protect access to {#ruby_task} in multithreading contexts
        def ruby_task_access(&block)
            @ruby_task_sync.synchronize(&block)
        end

        # @return [OroGen::Spec::Loader] loader used by all operations that require
        #   accessing orogen information. This is mostly used for types.
        attr_reader :default_loader
    end

    @use_mq_warning = true
    @keep_runkit_logfile = false
    @warn_for_missing_default_loggers = true
    @ruby_task_sync = Mutex.new

    @macos = /[Dd]arwin/.match?(RbConfig::CONFIG["host_os"])
    def self.macos?
        @macos
    end

    @windows = /(msdos|mswin|djgpp|mingw|[Ww]indows)/.match?(RbConfig::CONFIG["host_os"])
    def self.windows?
        @windows
    end

    def self.shared_library_suffix
        if macos?
            "dylib"
        elsif windows?
            "dll"
        else
            "so"
        end
    end

    def self.orocos_target
        ENV["OROCOS_TARGET"] || "gnulinux"
    end

    # Returns true if Runkit.load has been called
    def self.loaded?
        @loaded
    end

    def self.load(name: "runkit_#{::Process.pid}", loader: create_default_loader)
        if loaded?
            raise AlreadyInitialized,
                  "Runkit is already loaded. Try to call 'clear' before calling 'load' "\
                  "a second time"
        end

        logfile = ENV["ORO_LOGFILE"] || File.expand_path("runkit.#{name}.txt")
        if ENV["ORO_LOGFILE"] && (ENV["ORO_LOGFILE"] != logfile)
            raise "trying to change the path to ORO_LOGFILE from #{runkit_logfile} "\
                  "to #{logfile}. This is not supported"
        end
        @runkit_logfile = ENV["ORO_LOGFILE"] = logfile

        @loaded_typekit_plugins.clear
        @default_loader = loader
        @max_sizes = Hash.new { |h, k| h[k] = {} }
        @runkit_self_name = name

        load_typekit "std"
        load_standard_typekits

        @loaded = true

        nil
    end

    def self.clear
        FileUtils.rm_f runkit_logfile if !keep_runkit_logfile? && runkit_logfile

        @ruby_task&.dispose
        @ruby_task = nil
        @max_sizes.clear

        CORBA.clear
        @loaded = false
        @initialized = false
    end

    def self.reset
        clear
        load
    end

    # Returns true if Runkit.initialize has been called and completed
    # successfully
    def self.initialized?
        @initialized
    end

    # Load system info and initialize the communication layer
    def self.initialize
        self.load unless loaded?
        Runkit.update_typekit_main_thread

        Runkit::CORBA.initialize
        @initialized = true
        @ruby_task = RubyTasks::TaskContext.new(@runkit_self_name)
    end

    # Calls a block with the no-blocking-call-in-thread check disabled
    #
    # This is used in tests, when we know we want to do a remote call, or in
    # places where it is guaranteed that the "remote" is actually co-localized
    # within the same process (e.g. readers, writers, ruby task context)
    def self.allow_blocking_calls
        unless block_given?
            current_thread = Runkit.no_blocking_calls_in_thread
            Runkit.no_blocking_calls_in_thread = nil
            return current_thread
        end

        forbidden = Runkit.no_blocking_calls_in_thread
        if forbidden && (forbidden != Thread.current)
            raise ThreadError,
                  "cannot call #allow_blocking_calls with a block "\
                  "outside of the forbidden thread"
        end

        Runkit.no_blocking_calls_in_thread = nil
        begin
            yield
        ensure
            Runkit.no_blocking_calls_in_thread = forbidden if forbidden
        end
    end

    def self.forbid_blocking_calls
        Runkit.no_blocking_calls_in_thread = Thread.current
    end

    def self.create_default_loader
        OroGen::Loaders::RTT.new(orocos_target)
    end

    def self.typelib_type_for(type, loader: Runkit.default_loader)
        if type.respond_to?(:name)
            type_name = typelib_type_name_for(type.name)
            return type if type_name == type.name
        else
            type_name = typelib_type_name_for(type)
        end

        loader.typelib_type_for(type_name)
    end
end

at_exit do
    if !Runkit.keep_runkit_logfile? && Runkit.runkit_logfile
        FileUtils.rm_f Runkit.runkit_logfile
    end
end
