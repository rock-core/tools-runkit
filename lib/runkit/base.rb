# frozen_string_literal: true

# The Runkit main class
module Runkit
    # Result value when reading a port whose value has already been read
    #
    # Unlike within RTT, 'NO_DATA' is represented by a false value
    #
    # @see NEW_DATA
    OLD_DATA = 0

    # Result value when reading a port which has a new (never read) value
    #
    # Unlike within RTT, 'NO_DATA' is represented by a false value
    #
    # @see OLD_DATA
    NEW_DATA = 1

    class AlreadyInitialized < RuntimeError; end
    class InternalError < RuntimeError; end
    class AmbiguousName < RuntimeError; end
    class PropertyChangeRejected < RuntimeError; end
    # @deprecated use OroGen::ConfigError instead
    ConfigError = OroGen::ConfigError

    class NotFound < RuntimeError; end
    class TypekitNotFound < NotFound; end
    TypekitTypeNotFound    = OroGen::NotTypekitType
    TypekitTypeNotExported = OroGen::NotExportedType

    # Emitted when an interface object is requested, that does not exist
    class InterfaceObjectNotFound < Runkit::NotFound
        attr_reader :task
        attr_reader :name

        def initialize(task, name)
            @task = task
            @name = name
            super()
        end
    end

    def self.register_pkgconfig_path(path)
        base_path = caller(1).first.gsub(/:\d+:.*/, "")
        ENV["PKG_CONFIG_PATH"] = "#{File.expand_path(path, File.dirname(base_path))}:#{ENV['PKG_CONFIG_PATH']}"
    end

    # Exception raised when the user tries an operation that requires the
    # component to be generated by oroGen, while the component is not
    class NotOrogenComponent < Exception; end

    # Base class for all exceptions related to communication with remote
    # processes
    class ComError < RuntimeError; end

    class << self
        # The main configuration manager object
        attr_reader :conf

        # The registry that is the union of all loaded typekits
        #
        # @return [Typelib::Registry]
        def registry
            default_loader.registry
        end

        # A project that can be used to create models on-the-fly using
        # {Runkit.default_loader}
        def default_project
            @default_project ||= OroGen::Spec::Project.new(Runkit.default_loader)
        end

        # If true, the runkit logfile that is being generated by this Ruby
        # process is kept. By default, it gets removed when the ruby process
        # terminates
        attr_predicate :keep_runkit_logfile?, true

        # The name of the runkit logfile for this Ruby process
        attr_reader :runkit_logfile

        # [RubyTasks::TaskContext] the ruby task context that is used to provide a RTT
        # interface to this Ruby process. Among other things, it manages the
        # data readers and writers
        attr_reader :ruby_task

        @@ruby_task_sync = Mutex.new

        # Protect access to {#ruby_task} in multithreading contexts
        def ruby_task_access(&block)
            @@ruby_task_sync.synchronize(&block)
        end

        attr_predicate :warn_for_missing_default_loggers?, true
    end
    @use_mq_warning = true
    @keep_runkit_logfile = false
    @warn_for_missing_default_loggers = true

    # The loader object that should be used to load typekits and projects
    #
    # @return [OroGen::Loaders::Aggregate]
    # @see default_loader
    def self.default_loader
        unless @default_loader
            @default_loader = DefaultLoader.new
            # Instanciate all the sub-loaders
            default_pkgconfig_loader
            default_file_loader
            ROS.default_loader
        end
        @default_loader
    end

    # The loader object that should be used to register additional oroGen models
    #
    # @return [OroGen::Loaders::Files]
    def self.default_file_loader
        Runkit.default_loader
        @default_file_loader ||= OroGen::Loaders::Files.new(default_loader)
    end

    # The loader object that should be used to load installed oroGen typekits
    # and projects
    #
    # @return [OroGen::Loaders::PkgConfig]
    # @see default_loader
    def self.default_pkgconfig_loader
        Runkit.default_loader
        @default_pkgconfig_loader ||= OroGen::Loaders::PkgConfig.new(runkit_target, default_loader)
    end

    @macos = RbConfig::CONFIG["host_os"] =~ %r!([Dd]arwin)!
    def self.macos?
        @macos
    end

    @windows = RbConfig::CONFIG["host_os"] =~ %r!(msdos|mswin|djgpp|mingw|[Ww]indows)!
    def self.windows?
        @windows
    end

    def self.shared_library_suffix
        if macos? then "dylib"
        elsif windows? then "dll"
        else "so"
        end
    end

    def self.runkit_target
        ENV["OROCOS_TARGET"] || "gnulinux"
    end

    # Loads a directory containing configuration files
    #
    # See the documentation of ConfigurationManager#load_dir for more
    # information
    def self.load_config_dir(dir)
        conf.load_dir(dir)
    end

    # Returns true if Runkit.load has been called
    def self.loaded?
        @loaded
    end

    def self.load(name = nil)
        raise AlreadyInitialized, "Runkit is already loaded. Try to call 'clear' before callign load a second time." if @loaded

        raise "trying to change the path to ORO_LOGFILE from #{runkit_logfile} to #{ENV['ORO_LOGFILE']}. This is not supported" if ENV["ORO_LOGFILE"] && runkit_logfile && (ENV["ORO_LOGFILE"] != runkit_logfile)

        ENV["ORO_LOGFILE"] ||= File.expand_path("runkit.#{name || 'runkitrb'}-#{::Process.pid}.txt")
        @runkit_logfile = ENV["ORO_LOGFILE"]

        @conf = ConfigurationManager.new
        @loaded_typekit_plugins.clear
        @max_sizes = Hash.new { |h, k| h[k] = {} }

        load_typekit "std"
        load_standard_typekits

        if Runkit::ROS.enabled?
            unless Runkit::ROS.loaded?
                # Loads all ROS projects that can be found in
                # Runkit::ROS#spec_search_directories
                Runkit::ROS.load
            end
        end
        @loaded = true

        nil
    end

    def self.clear
        FileUtils.rm_f runkit_logfile if !keep_runkit_logfile? && runkit_logfile

        @ruby_task&.dispose
        default_loader.clear

        @max_sizes.clear

        Runkit::CORBA.clear
        @name_service = nil
        Runkit::Async.clear if defined? Runkit::Async
        Runkit::ROS.clear if Runkit::ROS.enabled?
        @loaded = false
        @initialized = false
    end

    def self.reset
        clear
        load
    end

    class << self
        attr_predicate :disable_sigchld_handler, true
    end

    # Returns true if Runkit.initialize has been called and completed
    # successfully
    def self.initialized?
        @initialized
    end

    # Initialize the Runkit communication layer and load all the oroGen models
    # that are available.
    #
    # This method will verify that the pkg-config environment is sane, as it is
    # demanded by the oroGen deployments. If it is not the case, it will raise
    # a RuntimeError exception whose message will describe the particular
    # problem. See the "Error messages" package in the user's guide for more
    # information on how to fix those.
    def self.initialize(name = "runkitrb_#{::Process.pid}")
        self.load(name) unless loaded?

        Runkit.update_typekit_main_thread

        # Install the SIGCHLD handler if it has not been disabled
        unless disable_sigchld_handler?
            trap("SIGCHLD") do
                loop do
                    dead_pid, dead_status = ::Process.wait2(-1, ::Process::WNOHANG)
                    break unless dead_pid

                    Runkit::Process.from_pid(dead_pid)&.dead!(dead_status)
                end
            rescue Errno::ECHILD
            end
        end

        Runkit::CORBA.initialize unless Runkit::CORBA.initialized?
        @initialized = true

        if Runkit::ROS.enabled?
            # ROS does not support being teared down and reinitialized.
            Runkit::ROS.initialize(name) unless Runkit::ROS.initialized?
        end

        # add default name services
        name_service << Runkit::CORBA.name_service
        name_service << Runkit::ROS.name_service if defined?(Runkit::ROS) && Runkit::ROS.enabled?
        if defined?(Runkit::Async)
            Runkit.name_service.name_services.each do |ns|
                Runkit::Async.name_service.add(ns)
            end
        end
        @ruby_task = RubyTasks::TaskContext.new(name)
    end

    def self.create_orogen_task_context_model(name = nil)
        OroGen::Spec::TaskContext.new(default_project, name)
    end

    def self.create_orogen_deployment_model(name = nil)
        OroGen::Spec::Deployment.new(default_project, name)
    end

    # @deprecated access default_loader.task_model_from_name directly instead
    def self.task_model_from_name(*args, &block)
        default_loader.task_model_from_name(*args, &block)
    end

    # Calls a block with the no-blocking-call-in-thread check disabled
    #
    # This is used in tests, when we know we want to do a remote call, or in
    # places where it is guaranteed that the "remote" is actually co-localized
    # within the same process (e.g. readers, writers, ruby task context)
    def self.allow_blocking_calls
        if block_given?
            forbidden = Runkit.no_blocking_calls_in_thread
            raise ThreadError, "cannot call #allow_blocking_calls with a block outside of the forbidden thread" if forbidden && (forbidden != Thread.current)

            Runkit.no_blocking_calls_in_thread = nil
            begin
                yield
            ensure
                Runkit.no_blocking_calls_in_thread = forbidden if forbidden
            end
        else
            current_thread = Runkit.no_blocking_calls_in_thread
            Runkit.no_blocking_calls_in_thread = nil
            current_thread
        end
    end

    def self.forbid_blocking_calls
        Runkit.no_blocking_calls_in_thread = Thread.current
    end
end

at_exit do
    FileUtils.rm_f Runkit.runkit_logfile if !Runkit.keep_runkit_logfile? && Runkit.runkit_logfile
end
