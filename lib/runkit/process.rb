# frozen_string_literal: true

require "utilrb/pkgconfig"
require "orogen"
require "fcntl"
require "json"

module Runkit # :nodoc:
    # Exception raised when there is no IOR registered for a given task name.
    class IORNotRegisteredError < Runkit::NotFound; end

    # Exception raised when the received IOR message is invalid.
    class InvalidIORMessage < Runkit::NotFound; end

    # The working directory that should be used by default in Runkit.run
    def self.default_working_directory
        @default_working_directory || Dir.pwd
    end

    # Resets the working directory that should be used by default in Runkit.run
    # to its default, that is the current directory at the time where Runkit.run
    # is called is used.
    def self.reset_working_directory
        @default_working_directory = nil
    end

    # Sets the working directory that should be used by default in Runkit.run.
    # By default, the current directory at the time where Runkit.run is called
    # is used.
    #
    # Use #reset_working_directory to use the default of using the current
    # directory.
    def self.default_working_directory=(value)
        value = File.expand_path(value)
        raise ArgumentError, "#{value} is not an existing directory" unless File.directory?(value)

        @default_working_directory = value
    end

    # The default commandline arguments that will be passed by default in Runkit.run
    def self.default_cmdline_arguments
        @default_cmdline_arguments || {}
    end

    # Resets the default arguments that should be used by default in Runkit.run
    # which is the default setting of the underlying oroGen components
    def self.reset_default_cmdline_arguments
        @default_cmdline_arguments = {}
    end

    # Sets the default commandline arguments that will be passed by default in Runkit.run
    #
    # Use #reset_default_arguments to use the default of the underlying oroGen components
    def self.default_cmdline_arguments=(value)
        unless default_cmdline_arguments.kind_of?(Hash)
            raise ArgumentError,
                  "Runkit.default_cmdline_arguments expects to be set as hash"
        end

        @default_cmdline_arguments = value
    end

    def self.tracing?
        @tracing_enabled
    end

    def self.tracing=(flag)
        @tracing_enabled = flag
    end

    def self.tracing_library_path
        File.join(
            Utilrb::PkgConfig.new("runkit-rtt-#{Runkit.orocos_target}").libdir,
            "librunkit-rtt-traces-#{Runkit.orocos_target}.so"
        )
    end

    # Base class for process representation objects
    class ProcessBase
        # The process name
        # @return [String]
        attr_reader :name
        # The deployment oroGen model
        # @return [OroGen::Spec::Deployment]
        attr_reader :model
        # @deprecated
        # For backward compatibility only
        def orogen
            model
        end

        # A set of mappings from task names in the deployment model to the
        # actual name in the running process
        attr_reader :ior_mappings

        def initialize(name, model, name_mappings: {})
            @name = name
            @model = model
            @name_mappings = name_mappings.dup

            @logged_ports = Set.new
            @ior_mappings = nil
            @ior_message = ""
            @ior_read_fd = nil
        end

        # Require that to rename the task called +old+ in this deployment to
        # +new+ during execution
        #
        # @see name_mappings name_mappings=
        def map_name(old, new)
            @name_mappings[old] = new
        end

        # @api private
        #
        # use a mapping if exists
        def mapped_name_for(name)
            @name_mappings.fetch(name, name)
        end

        # Returns the name of the tasks that are running in this process
        #
        # See also #each_task
        def task_names
            unless model
                raise Runkit::NotOrogenComponent,
                      "#{name} does not seem to have been generated by orogen"
            end

            model.task_activities.map do |deployed_task|
                name = deployed_task.name
                mapped_name_for(name)
            end
        end

        # Enumerate the TaskContext instances of the tasks that are running in
        # this process.
        #
        # See also #task_names
        def each_task
            return enum_for(:each_task) unless block_given?

            task_names.each do |name|
                yield(task(name))
            end
        end

        # Get the task context object for one of this deployment's tasks
        # or raises Runkit::NotFound.
        def task(mapped_task_name)
            unless (ior = ior_for(mapped_task_name))
                raise Runkit::IORNotRegisteredError,
                      "no IOR is registered for #{mapped_task_name}"
            end

            deployed_task = model.task_activities.find do |t|
                mapped_name_for(t.name) == mapped_task_name
            end
            TaskContext.new(
                ior, name: mapped_task_name, model: deployed_task.task_model
            )
        end

        # Get the IOR of one of this deployment's tasks
        #
        # @param [String] mapped_task_name the real name of the task
        # @return [String,nil] the task's IOR, or nil if it is not known
        def ior_for(mapped_task_name)
            @ior_mappings&.fetch(mapped_task_name, nil)
        end

        # @api private
        #
        # Applies a prefix to this process' task names and returns the names
        #
        # @param [OroGen::Spec::Deployment] model the deployment model
        # @param [String,nil] prefix the prefix string, no prefix is going to be
        #   applied if it is nil
        #
        # @return [Hash<String,String>] the name mappings that should be applied
        #   when spawning the process
        def self.resolve_prefix(model, prefix)
            name_mappings = {}
            if prefix
                model.task_activities.each do |act|
                    name_mappings[act.name] = "#{prefix}#{act.name}"
                end
            end
            name_mappings
        end

        # Read the IOR pipe and parse the received message, closing the read file
        # descriptor when end of file is reached.
        #
        # @return [nil, Hash<String, String>] when eof is reached and the message is valid
        #   return a { task name => ior } hash. Returns nil if the process dies, or if we
        #   have not yet received all the IOR information from it.
        def try_resolve_running_tasks(channel: @ior_read_fd)
            return unless alive?

            begin
                loop do
                    @ior_message += channel.read_nonblock(4096)
                end
            rescue IO::WaitReadable
                nil
            rescue EOFError
                channel.close
                load_and_validate_ior_message(@ior_message)
            end
        end

        # Waits the running tasks resolution for a given amount of time.
        #
        # @param [nil, Boolean, Float] timeout when nil, this method blocks until all the
        #   running tasks are resolved or the process crashes. When given a number, it
        #   block for the given amount of time in milliseconds. When given a boolean, false
        #   is equivalent as passing 0 as argument, and true is equivalent to passing nil.
        # @return [Hash<String, String>] mappings of { task name => IOR }
        # @raise Runkit::NotFound if the process dies during execution
        # @raise Runkit::InvalidIORMessage if the message received is invalid
        def wait_running(timeout = nil, channel: @ior_read_fd, &block)
            return block.call if block_given?
            return @ior_mappings if @ior_mappings

            start_time = Time.now
            timeout = transform_timeout(timeout)
            deadline = start_time + timeout unless timeout == Float::INFINITY
            got_alive = alive?
            loop do
                @ior_mappings = try_resolve_running_tasks(channel: channel)
                return @ior_mappings if @ior_mappings
                break if timeout < Time.now - start_time

                raise Runkit::NotFound, "#{name} was started but crashed" if got_alive && !alive?

                time_until_deadline = [deadline - Time.now, 0].max if deadline
                IO.select([channel], nil, nil, time_until_deadline)
            end

            raise Runkit::NotFound, "cannot get a running #{name} module" unless alive?
        end

        def transform_timeout(timeout)
            return timeout if timeout.kind_of?(Numeric)

            return Float::INFINITY if timeout.nil? || timeout == true

            0
        end

        # Load and validate the ior message read from the IOR pipe.
        #
        # @param [String] message the ior message read from the pipe
        # @return [Hash<String, String>, nil] the parsed ior message as a
        #   { task name => ior} hash, or nil if the message could not be parsed.
        # @raise Runkit::InvalidIORMessage raised if any task name present in the message
        #   is not present in the process' task names.
        def load_and_validate_ior_message(message)
            begin
                message = JSON.parse(message)
            rescue JSON::ParserError
                return
            end

            all_included = message.keys.all? { |name| task_names.include?(name) }
            return message if all_included

            raise Runkit::InvalidIORMessage,
                  "the following tasks were present on the ior message but werent in "\
                  "the process task names: #{message.keys - task_names}"
        end
    end

    # The representation of an Runkit process. It manages
    # starting the process and cleaning up when the process
    # dies.
    class Process < ProcessBase
        # The path to the binary file
        attr_reader :binfile
        # The component process ID
        attr_reader :pid

        # Create a Process object that deploys the given orogen model
        #
        # @overload for_orogen_model(task_m => "name")
        #   Returns a Process that would deploy the given task using its
        #   default deployment, renamed to "name"
        #
        #   @return [Process]
        #
        # @overload for_orogen_model(deployment_m)
        #   Returns a Process that would deploy the given deployment
        #
        #   @return [Process]
        #
        # @overload for_orogen_model(deployment_m => "prefix_")
        #   Returns a Process that would deploy the given deployment, with
        #   "prefix_" applied to its task name
        #
        #   @return [Process]
        def self.for_orogen_model(spec, loader: Runkit.default_loader)
            name, deployment_m, name_mappings, =
                parse_run_options(spec, loader: loader).first
            new(name, deployment_m, loader: loader, name_mappings: name_mappings)
        end

        # Creates a new Process instance which will be able to
        # start and supervise the execution of the given Runkit
        # component
        #
        # @param [String] name the process name
        # @param [OroGen::Spec::Deployment] model the process deployment'
        #
        # @overload initialize(name, model_name = name)
        #   deprecated form
        #   @param [String] name the process name
        #   @param [String] model_name the name of the deployment model
        #
        def initialize(name, model, loader: model.loader, name_mappings: {})
            @binfile = loader.find_deployment_binfile(model.name)
            super(name, model, name_mappings: name_mappings)
        end

        # Waits until the process dies
        #
        # This is valid only if the module has been started
        # under Runkit supervision, using {#spawn}
        def join
            return unless alive?

            begin
                _, exit_status = ::Process.waitpid2(pid)
            rescue Errno::ECHILD # rubocop:disable Lint/SuppressedException
            end

            dead!(exit_status)
        end

        # True if the process is running
        def alive?
            @pid && !@exit_status
        end

        # True if the process is running
        def running?
            alive?
        end

        # Called externally to announce a component dead.
        def dead!(exit_status) # :nodoc:
            exit_status = (@exit_status ||= exit_status)
            if !exit_status
                Runkit.info "deployment #{name} exited, exit status unknown"
            elsif exit_status.success?
                Runkit.info "deployment #{name} exited normally"
            elsif exit_status.signaled?
                if @expected_exit == exit_status.termsig
                    Runkit.info "deployment #{name} terminated with signal #{exit_status.termsig}"
                elsif @expected_exit
                    Runkit.info "deployment #{name} terminated with signal #{exit_status.termsig} but #{@expected_exit} was expected"
                else
                    Runkit.error "deployment #{name} unexpectedly terminated with signal #{exit_status.termsig}"
                end
            else
                Runkit.warn "deployment #{name} terminated with code #{exit_status.to_i}"
            end
        end

        class TaskNameRequired < ArgumentError; end

        # Converts the options given to Runkit.run in a more normalized format
        #
        # It returns a triple (deployments, models, options) where
        #
        # * \c deployments is a map from a deployment name to a prefix that should
        #   be used to run this deployment. Prefixes are prepended to all task
        #   names in the deployment. It is set to nil if there are no prefix.
        # * \c models is a mapping from a oroGen model name to a name. It
        #   requests to start the default deployment for the model_name, using
        #   \c name as the task name
        # * options are options that should be passed to #spawn
        #
        # For instance, in
        #
        #   Runkit.run 'xsens', 'xsens_imu::Task' => 'imu', :valgrind => true
        #
        # One deployment called 'xsens' should be called with no prefix, the
        # default deployment for xsens_imu::Task should be started and the
        # corresponding task be renamed to 'imu' and all deployments should be
        # started with the :valgrind => true option. Therefore, the parsed
        # options would be
        #
        #   deployments = { 'xsens' => nil }
        #   models = { 'xsens_imu::Task' => 'imu' }
        #   options = { valgrind => true }
        #
        # In case multiple instances of a single model need to be started, the
        # names can be given as an Array. E.g.
        #
        #   Runkit.run 'xsens_imu::Task' => ['imu1', 'imu2']
        #
        def self.partition_run_options(*names, loader: Runkit.default_loader)
            mapped_names = {}
            mapped_names = names.pop if names.last.kind_of?(Hash)

            deployments = {}
            models = {}
            names.each { |n| mapped_names[n] = nil }
            mapped_names.each do |object, new_name|
                # If given a name, resolve to the corresponding oroGen spec
                # object
                if object.respond_to?(:to_str) || object.respond_to?(:to_sym)
                    object = object.to_s
                    begin
                        object = loader.task_model_from_name(object)
                    rescue OroGen::NotFound => task_e
                        begin
                            object = loader.deployment_model_from_name(object)
                        rescue OroGen::NotFound => deployment_e
                            raise OroGen::NotFound,
                                  "#{object} is neither a task model "\
                                  "nor a deployment name: #{task_e} and #{deployment_e}"
                        end
                    end
                end

                case object
                when OroGen::Spec::TaskContext
                    unless new_name
                        raise TaskNameRequired,
                              "you must provide a task name when starting a component "\
                              "by type, as e.g. Runkit.run 'xsens_imu::Task' => 'xsens'"
                    end

                    models[object] = Array(new_name)
                when OroGen::Spec::Deployment
                    deployments[object] = new_name
                else
                    raise ArgumentError,
                          "expected a task context model or a deployment model, "\
                          "got #{object}"
                end
            end
            [deployments, models]
        end

        # @api private
        #
        # Separate the list of deployments from the spawn options in options
        # passed to {Runkit.run}
        #
        # Valid options are:
        # @param [String] output
        #   redirect the process output to the given file. The %m and %p
        #   patterns will be replaced by respectively the name and the PID of
        #   each process.
        # @param [Boolean,Array<String>] valgrind
        #   start some or all the processes under valgrind. It can either be an
        #   array of process names (e.g. valgrind: ['p1', 'p2']) or 'true'.
        #   In the first case, the listed processes will be added to the list of
        #   processes to start (if they are not already in it) and will be
        #   started under valgrind. In the second case, all processes are
        #   started under valgrind.
        # @param [Array<String>] valgrind_options
        #   an array of options that should be passed to valgrind, e.g.
        #     valgrind_options: ["--track-origins=yes"]
        # @param [Boolean,Array<String>] gdb
        #   start some or all the processes under gdbserver. It can either be an
        #   array of process names (e.g. gdbserver: ['p1', 'p2']) or 'true'.
        #   In the first case, the listed processes will be added to the list of
        #   processes to start (if they are not already in it) and will be
        #   started under gdbserver. In the second case, all processes are
        #   started under gdbserver.
        # @param [Array<String>] gdb_options
        #   an array of options that should be passed to gdbserver
        #
        # @param [Hash<String>] cmdline_args
        #   When command line arguments are available to deployments, they can be
        #   set using the following option:
        #      cmdline_args: { "sd-domain" => '_robot._tcp', "prefix" => "test" }
        #   This will be mapped to '--sd-domain=_robot._tcp --prefix=test'
        #
        #   One notable command line argument is --sd-domain
        #   The service discovery domain in which this process should be published
        #   This is only supported by deployments and orogen if the service_discovery
        #   package has been installed along with orogen
        #   The sd domain is of the format: <name>.<suffix> where the suffix has to
        #   be one of _tcp or _udp
        def self.parse_run_options(*names, loader: Runkit.default_loader,
            valgrind: false, valgrind_options: {},
            gdb: false, gdb_options: {},
            log_level: nil,
            output: nil, oro_logfile: "runkit.%m-%p.txt",
            working_directory: Runkit.default_working_directory,
            cmdline_args: {})
            deployments, models = partition_run_options(*names, loader: loader)

            name_mappings = resolve_name_mappings(deployments, models, loader)
            deployment_names = name_mappings.map(&:first)
            valgrind = parse_cmdline_wrapper_option(
                "valgrind", valgrind, valgrind_options, deployment_names
            )
            gdb = parse_cmdline_wrapper_option(
                "gdbserver", gdb, gdb_options, deployment_names
            )
            log_level = parse_log_level_option(log_level, deployment_names)

            processes = name_mappings.map do |name, deployment, mappings|
                output = (output&.gsub "%m", name)

                spawn_options = {
                    working_directory: working_directory,
                    output: output,
                    valgrind: valgrind[name],
                    gdb: gdb[name],
                    cmdline_args: cmdline_args,
                    log_level: log_level[name],
                    oro_logfile: oro_logfile
                }
                [name, deployment, mappings, spawn_options]
            end
            processes
        end

        # @api private
        #
        # Normalizes the log_level option passed to {Runkit.run}.
        #
        # @param [Hash,Symbol] options is given as a symbol, this is the log
        # level that should be applied to all deployments. Otherwise, it is a
        # hash from a process name to the log level that should be applied for
        # this particular deployment
        # @param [Array<String>] all_deployments the name of all deployments
        # @return [Hash<String,Symbol>] a hash from a name in all_deployments to
        #   the log level for that deployment
        def self.parse_log_level_option(options, all_deployments)
            if !options.respond_to?(:to_hash)
                all_deployments.each_with_object({}) { |name, h| h[name] = options; }
            else
                options
            end
        end

        # @api private
        #
        # Checks that the given command can be resolved
        def self.command?(cmd)
            if File.file?(cmd) && File.executable?(cmd)
                nil
            else
                system("which #{cmd} > /dev/null 2>&1")
            end
        end

        # @api private
        #
        # Normalizes the options for command line wrappers such as gdb and
        # valgrind as passed to {Runkit.run}
        #
        # @overload parse_cmdline_wrapper_option(cmd, enable, cmd_options, deployments)
        #   @param [String] cmd the wrapper command string
        #   @param [Boolean] enable whether the wrapper should be enabled or not
        #   @param [Hash] options additional options to pass to the wrapper
        #   @param [Array<String>] deployments the deployments on which the
        #     wrapper should be activated
        #
        # @overload parse_cmdline_wrapper_option(cmd, deployments, cmd_options, all_deployments)
        #   @param [String] cmd the wrapper command string
        #   @param [Array<String>] deployments the name of the deployments on which
        #     the wrapper should be used.
        #   @param [Hash] options additional options to pass to the wrapper
        #   @param [Array<String>] all_deployments ignored in this form
        #
        # @overload parse_cmdline_wrapper_option(cmd, deployments_to_cmd_options, cmd_options, all_deployments)
        #   @param [String] cmd the wrapper command string
        #   @param [Hash<String,Array<String>>] deployments_to_cmd_options
        #     mapping from name of deployments to the list of additional options
        #     that should be passed to the wrapper
        #   @param [Hash] options additional options to pass to the wrapper
        #   @param [Array<String>] all_deployments ignored in this form
        #
        def self.parse_cmdline_wrapper_option(
            cmd, wrapper_flag, wrapper_options, deployments
        )
            return {} unless wrapper_flag

            unless command?(cmd)
                raise "'#{cmd}' option is specified, but #{cmd} seems not to be installed"
            end

            unless wrapper_flag.respond_to?(:to_hash)
                if wrapper_flag.respond_to?(:to_str)
                    wrapper_flag = [wrapper_flag]
                elsif !wrapper_flag.respond_to?(:to_ary)
                    wrapper_flag = deployments
                end

                wrapper_flag = wrapper_flag.each_with_object({}) do |name, h|
                    h[name] = wrapper_options
                end
            end

            wrapper_flag.each_key do |name|
                next if deployments.include?(name)

                raise ArgumentError,
                      "#{name}, selected to be executed under #{cmd}, "\
                      "is not a known deployment/model"
            end

            wrapper_flag
        end

        # @api private
        #
        # Resolve the 'prefix' options given to {Runkit.run} into an exhaustive
        # task name mapping
        #
        # @param [Array<(OroGen::Spec::Deployment,String)>] deployments the list
        #   of deployments that should be started along with a prefix string
        #   that should be prepended to the deployment's tasks
        # @param [Array<(OroGen::Spec::TaskContext,String)>] models a list of
        #   task context models that should be deployed, along with the task
        #   name that should be used for these models.
        # @return [Array<(String,Hash,String)>] a tuple of the name of a binary,
        #   the name mappings that should be used when spawning this binary and
        #   the desired process name.
        def self.resolve_name_mappings(deployments, models, loader)
            processes = []
            processes += deployments.map do |deployment, prefix|
                if prefix
                    ["#{prefix}#{deployment.name}",
                     deployment,
                     ProcessBase.resolve_prefix(deployment, prefix)]
                else
                    [deployment.name, deployment, {}]
                end
            end
            models.each do |model, desired_names|
                desired_names = [desired_names] unless desired_names.kind_of? Array
                desired_names.each do |desired_name|
                    process_name =
                        OroGen::Spec::Project.default_deployment_name(model.name)
                    deployment = loader.deployment_model_from_name(process_name)
                    name_mappings = Hash[
                        process_name => desired_name,
                        "#{process_name}_Logger" => "#{desired_name}_Logger"]

                    processes << [desired_name, deployment, name_mappings]
                end
            end
            processes
        end

        def self.gdb_base_port=(port)
            @gdb_port = port - 1
        end

        @gdb_port = 30_000
        def self.allocate_gdb_port
            @gdb_port += 1
        end

        VALID_LOG_LEVELS = %i[debug info warn error fatal disable].freeze

        CommandLine = Struct.new :env, :command, :args, :working_directory

        # Massages various spawn parameters into the actual deployment command line
        #
        # @return [CommandLine]
        def command_line(
            working_directory: Runkit.default_working_directory,
            log_level: nil,
            cmdline_args: {},
            tracing: Runkit.tracing?, gdb: nil, valgrind: nil,
            name_service_ip: Runkit::CORBA.name_service_ip
        )

            result = CommandLine.new({}, nil, [], working_directory)
            result.command = binfile

            result.env["LD_PRELOAD"] = Runkit.tracing_library_path if tracing
            if log_level
                valid_levels = %i[debug info warn error fatal disable]
                if valid_levels.include?(log_level)
                    result.env["BASE_LOG_LEVEL"] = log_level.to_s.upcase
                else
                    raise ArgumentError, "'#{log_level}' is not a valid log level." +
                                         " Valid options are #{valid_levels}."
                end
            end
            result.env["ORBInitRef"] = "NameService=corbaname::#{name_service_ip}" if name_service_ip

            cmdline_args = cmdline_args.dup
            cmdline_args[:rename] ||= []
            name_mappings.each do |old, new|
                cmdline_args[:rename].push "#{old}:#{new}"
            end

            # Command line arguments have to be of type --<option>=<value>
            # or if <value> is nil a valueless option, i.e. --<option>
            cmdline_args.each do |option, value|
                if value
                    if value.respond_to?(:to_ary)
                        value.each do |v|
                            result.args.push "--#{option}=#{v}"
                        end
                    else
                        result.args.push "--#{option}=#{value}"
                    end
                else
                    result.args.push "--#{option}"
                end
            end

            if gdb
                result.args.unshift(result.command)
                gdb = Process.allocate_gdb_port if gdb == true
                result.args.unshift("0.0.0.0:#{gdb}")
                result.command = "gdbserver"
            elsif valgrind
                result.args.unshift(result.command)
                result.command = "valgrind"
            end

            result
        end

        # Spawns this process
        #
        # @param [Symbol] log_level the log level under which the process should
        #   be run. Must be one of {VALID_LOG_LEVELS}
        # @param [String] working_directory the working directory
        # @param [String] oro_logfile the name of the RTT-generated logfile.
        #   %m will be replaced by the process' name and %p by its PID
        # @param [String] prefix a prefix that should be prepended to all tasks
        #   in the process
        # @param [Boolean] tracing whether the tracing library
        #   {Runkit.tracing_library_path} should be preloaded before executing the
        #   process
        # @param [#get] name_service a name service object that should be used
        #   to resolve the tasks
        # @param [Boolean,Array<String>] gdb whether the process should be
        #   executed under the supervision of gdbserver. Setting this option to
        #   true will enable gdb support. Setting it to an array of strings will
        #   specify a list of arguments that should be passed to gdbserver. This
        #   is obviously incompatible with the valgrind option. A warning
        #   message is issued, that describes how to connect to the gdbserver
        #   instance.
        # @param [Boolean,Array<String>] valgrind whether the process should be
        #   executed under the supervision of valgrind. Setting this option to
        #   true will enable valgrind support. Setting it to an array of strings will
        #   specify a list of arguments that should be passed to valgrind
        #   itself. This is obviously incompatible with the gdb option.
        def spawn(
            log_level: nil, working_directory: Runkit.default_working_directory,
            cmdline_args: {},
            oro_logfile:  "runkit.%m-%p.txt",
            tracing: Runkit.tracing?,
            output: nil,
            gdb: nil, valgrind: nil,
            env: {}
        )

            raise "#{name} is already running" if alive?

            Runkit.info "starting deployment #{name}"

            cmdline_args = cmdline_args.dup
            cmdline_args[:rename] ||= []
            @name_mappings.each do |old, new|
                cmdline_args[:rename].push "#{old}:#{new}"
            end

            if valgrind
                cmdline_wrapper = "valgrind"
                cmdline_wrapper_options =
                    if valgrind.respond_to?(:to_ary)
                        valgrind
                    else []
                    end
            elsif gdb
                cmdline_wrapper = "gdbserver"
                cmdline_wrapper_options =
                    if gdb.respond_to?(:to_ary)
                        gdb
                    else []
                    end
                gdb_port = Process.allocate_gdb_port
                cmdline_wrapper_options << "localhost:#{gdb_port}"
            end

            cmdline = [binfile]

            # check arguments for log_level
            if log_level
                valid_levels = %i[debug info warn error fatal disable]
                if valid_levels.include?(log_level)
                    log_level = log_level.to_s.upcase
                else
                    raise ArgumentError, "'#{log_level}' is not a valid log level." +
                                         " Valid options are #{valid_levels}."
                end
            end

            @ior_read_fd, ior_write_fd = IO.pipe
            read, write = IO.pipe
            @pid = fork do
                @ior_read_fd.close
                # Pass write file descriptor for the IOR pipe as a commandline argument
                cmdline_args["ior-write-fd"] = ior_write_fd.fileno

                env["LD_PRELOAD"] = Runkit.tracing_library_path if tracing

                pid = ::Process.pid
                env["BASE_LOG_LEVEL"] = log_level if log_level

                if output&.respond_to?(:to_str)
                    output_file_name = output
                                       .gsub("%m", name)
                                       .gsub("%p", pid.to_s)
                    output_file_name = File.expand_path(output_file_name, working_directory) if working_directory

                    output = File.open(output_file_name, "a")
                end

                if oro_logfile
                    oro_logfile = oro_logfile
                                  .gsub("%m", name)
                                  .gsub("%p", pid.to_s)
                    oro_logfile = File.expand_path(oro_logfile, working_directory) if working_directory
                    env["ORO_LOGFILE"] = oro_logfile
                else
                    env["ORO_LOGFILE"] = "/dev/null"
                end

                if output
                    STDERR.reopen(output)
                    STDOUT.reopen(output)
                end

                cmdline.unshift "--log-file=#{output_file_name}.valgrind" if output_file_name && valgrind

                if cmdline_wrapper
                    cmdline = cmdline_wrapper_options + cmdline
                    cmdline.unshift cmdline_wrapper
                end

                # Command line arguments have to be of type --<option>=<value>
                # or if <value> is nil a valueless option, i.e. --<option>
                cmdline_args&.each do |option, value|
                    if value
                        if value.respond_to?(:to_ary)
                            value.each do |v|
                                cmdline.push "--#{option}=#{v}"
                            end
                        else
                            cmdline.push "--#{option}=#{value}"
                        end
                    else
                        cmdline.push "--#{option}"
                    end
                end

                read.close
                ::Process.setpgrp
                begin
                    exec(env, *cmdline, ior_write_fd => ior_write_fd, chdir: working_directory)
                rescue Exception
                    write.write("FAILED")
                end
            end

            ior_write_fd.close
            write.close
            raise "cannot start #{name}" if read.read == "FAILED"

            Runkit.warn "process #{name} has been started under gdbserver, port=#{gdb_port}. The components will not be functional until you attach a GDB to the started server" if gdb
        end

        # Return the mapping of name to task object
        #
        # @raise (see #task)
        def resolve_all_tasks
            each_task.each_with_object({}) do |task, resolved_tasks|
                resolved_tasks[task.name] = task
            end
        end

        SIGNAL_NUMBERS = {
            "SIGABRT" => 1,
            "SIGINT" => 2,
            "SIGKILL" => 9,
            "SIGSEGV" => 11
        }.freeze

        # Tries to stop and cleanup the provided task. Returns true if it was
        # successful, and false otherwise
        def self.try_task_cleanup(task)
            begin
                task.stop
                task.cleanup if task.model&.needs_configuration?
            rescue StateTransitionFailed # rubocop:disable Lint/SuppressedException
            end

            task.each_port(&:disconnect_all)

            true
        rescue StandardError => e
            Runkit.warn "clean shutdown of #{task.name} failed: #{e.message}"
            e.backtrace.each do |line|
                Runkit.warn line
            end
            false
        end

        # Kills the process either cleanly by requesting a shutdown if signal ==
        # nil, or forcefully by using UNIX signals if signal is a signal name.
        def kill(signal = nil, cleanup: !signal, hard: false)
            tpid = pid
            return unless tpid # already dead

            signal ||=
                if hard
                    "SIGKILL"
                else
                    "SIGINT"
                end

            # Stop all tasks and disconnect the ports
            if cleanup
                clean_shutdown = true
                begin
                    each_task do |task|
                        unless self.class.try_task_cleanup(task)
                            clean_shutdown = false
                            break
                        end
                    end
                rescue Runkit::NotFound
                    # We're probably still starting the process. Just go on and
                    # signal it
                    clean_shutdown = false
                end
                Runkit.warn "clean shutdown of process #{name} failed" unless clean_shutdown
            end

            expected_exit = nil
            if signal
                signal = "SIG#{signal}" if signal.respond_to?(:to_str) && signal !~ /^SIG/

                expected_exit ||=
                    if signal.kind_of?(Integer) then signal
                    else SIGNAL_NUMBERS[signal] || signal
                    end

                Runkit.warn "sending #{signal} to #{name}" unless expected_exit
                @expected_exit = expected_exit
                begin
                    ::Process.kill(signal, tpid)
                rescue Errno::ESRCH
                    # Already exited
                    return
                end
            end

            nil
        end
    end
end
